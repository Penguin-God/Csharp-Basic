using System;

namespace Data_Basic
{
    class Program
    {
        // Main 함수는 언어 불문하고 모든 프로그램 내에 하나만 있어야 하는 함수
        static void Main(string[] args)
        {
            // byte(1바이트 0 ~ 255), short(2바이트 -3만 ~ 3만), int(4바이트 -21억 ~ 21억), long(8바이트 싹 다)
            // 범위가 큰 자료형에서 작은 자료형을 빼거나 더하거나 대입하는 것은 가능하지만 반대는 안됨
            // 기획이 언제 바뀔 줄 모르니까 범위에 여유 좀 두기 ( ??? : 아 원래는 레벨이 100까지였는데 2000까지 늘리는거 가능한가요? )
            // 아이템 고유 번호 같이 생성됨에 따라 끝도 없이 늘어나는 변수는 long 같은 걸로 해두기

            // 범위 최솟값에서 1 빼면 최댓값 됨 은행 같은데 해킹 할때 쓰는 방법 중 하나( ??? : 0에서 1 빼면 4조가 나오는 마술!!! )
            // 최댓값에서 더해서 반대도 가능함
            int number = -2100000000;
            number -= 100000000;
            //Console.WriteLine("Hello Wolrd! {0}", number);

            // 10진수 : 평소에 우리가 쓰는거
            // 한자릿 수 : 01, 02, 03, 04, 05, 06, 07, 08, 09
            // 09에 01 더하면 9 다음이 없으니까 0으로 리셋되고 0은 1로 승격되서 10이 됨

            // 2진수 : 컴퓨터가 쓰는거
            // 표시 가능한거 : 0b00, 0b01 (0b는 2진수 앞에 붙이는 식별자)
            // 10진수랑 똑같이 0b01 다음에 쓸게 없으니까 앞에건 올리고 뒤에건 리셋시킴
            // 0b00, 0b01, 0b10, 0b11, 0b100, 0b101 ...........

            // 16진수 : 존나게 길다는 2진수의 단점을 메꿀 수 있는거
            // 01~09, A, B, C, D, E, F (10번째 넘어가면 숫자로 표현 못하니까 알파벳 가져온거 대소문자 구분 안함)
            // 여기는 0x 붙임
            // 0x01.... 0x0F, 0x10 (표시할거 없으면 리셋되고 앞에거 올라가는거 똑같음)

            // 2진수와 16진수의 변환
            // 2진수의 4자릿수로 표현가능한 형태는 총 16가지임 즉 16진수로 변환이 쉬움
            // 0b10001111 = 0b 1000 1111 = 0x 08 0F = 0x080F
            // 위에서처럼 4자리수로 끊으면 변환이 쉬움

            // 1bit 는 00, 01 처럼 전기 신호가 있는지 없는지 판별하는 최소 단위
            // 1byte는 1bit가 8개 있는거
            // 0b11111111 = 0b10000000 + 0b01000000... + 0b00000001 = 255
            // 따라서 1byte의 크기를 가진 자료형 byte가 표시할 수 있는 범위는 0~255

            // 음수의 표현
            // 가장 큰 10000000(128)을 음수로 사용 그러면 0b11111111 = -1
            // 즉 1바이트는 -128~127 까지 표현 가능
            // 이렇게 음수를 표현할 경우 0을 -0, +0 처럼 안 나누고 표현 가능
            // 음수값을 양수값으로 바꾸는게 편함 (이진수 0, 1 뒤집고 1(0001) 더하면 됨)

            // 4바이트 소수점 7자리 정도까지 정확
            float f = 2.33f;

            // 8바이트
            double d = 2.33;

            // 소수 연산은 정수형보다 훨씬 더 복잡하고 비쌈
            double da = f + d;


            // 형변환
            byte fff = 255;
            // sbyte( -128 ~ 127 ) : 최상위 비트를 음수로 인식
            sbyte kkk = (sbyte)fff;
            // byte에서 255는 0b11111111 sbyte에서는 최상위 비트(128)가 음수이므로 0b11111111 은 -1이므로 kkk의 값은 -1이 됨

            int aaaa = 0x0FFFFFFF;
            short bbbb = (short)aaaa;
            // short는 2비트까지만 0x0FFFFFFF 에서 앞의 0FFF 는 표현하지 못하고 뒤의 FFFF만 표현 가능하며 0xFFFF는 -1 이다.

            // break point : 디버그 모드로 실행했을 때 라인을 클릭하면 생기는 빨간 줄에서 코드가 끊기고 데이터 정보를 마우스 오버로 볼 수 있음

            // 소수는 형변환 시 정확한 값이 아니라 가장 인접한 값을 내는 경우가 대부분이기 때문에 예상하지 못한 결과가 나올수도 있음
            // 3.1414 변환하면 3.1414000623000122 로 변하고 그러기 때문에 조건문에서 == 보다는 오차를 어느 정도 감안하고 비교해야 함

            int hp = 100;
            // hp++ 은 코드 실행 후 연산 ++hp는 코드 실행 전에 연산
            // Console.WriteLine(hp++); // 100
            // Console.WriteLine(++hp); // 101



            // 비트 연산자 : <<  >>  &(and)  |(or)  ^(xor)  ~(not)
            int num = 1;
            // << : int는 4바이트로 0b00000000000000000000000000000001 인데 1을 왼쪽으로 3칸 밀어서 0b00000000000000000000000000001000 만드는 것
            num = num << 3;
            // >> : 이건 왼쪽으로 미는거
            num = num >> 3;

            // 끝부분에서 더 밀면 절벽으로 떨어지는것마냥 0되버림

            // 만약 음수를 포함하고 최상위 비트가 있는 상태를 밀면 밀리는게 최상위 비트는 남고 복사를 해버림
            // 0b10000000000000010000000000000010 인 상태로 하나 밀면 0b11000000000000001000000000000001 가 되버림
            // 그래서 비트 연산을 할때는 음수를 포함하지 않는 uint를 사용하면 좋음 uint( 0 ~ 43억 )
            // uint 사용하면 인생이 편해짐
        }
    }
}
