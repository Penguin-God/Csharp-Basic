byte(1바이트 0 ~ 255), short(2바이트 -3만 ~ 3만), int(4바이트 -21억 ~ 21억), long(8바이트 싹 다)
범위가 큰 자료형에서 작은 자료형을 빼거나 더하거나 대입하는 것은 가능하지만 반대는 안됨
기획이 언제 바뀔 줄 모르니까 범위에 여유 좀 두기 ( ??? : 아 원래는 레벨이 100까지였는데 2000까지 늘리는거 가능한가요? )
아이템 고유 번호 같이 생성됨에 따라 끝도 없이 늘어나는 변수는 long 같은 걸로 해두기

범위 최솟값에서 1 빼면 최댓값 됨 은행 같은데 해킹 할때 쓰는 방법 중 하나( ??? : 0에서 1 빼면 4조가 나오는 마술!!! )
최댓값에서 더해서 반대도 가능함
int number = -2100000000;
number -= 100000000;
Console.WriteLine("Hello Wolrd! {0}", number);

10진수 : 평소에 우리가 쓰는거
한자릿 수 : 01, 02, 03, 04, 05, 06, 07, 08, 09
09에 01 더하면 9 다음이 없으니까 0으로 리셋되고 0은 1로 승격되서 10이 됨

2진수 : 컴퓨터가 쓰는거
표시 가능한거 : 0b00, 0b01 (0b는 2진수 앞에 붙이는 식별자)
10진수랑 똑같이 0b01 다음에 쓸게 없으니까 앞에건 올리고 뒤에건 리셋시킴
0b00, 0b01, 0b10, 0b11, 0b100, 0b101 ...........

16진수 : 존나게 길다는 2진수의 단점을 메꿀 수 있는거
01~09, A, B, C, D, E, F (10번째 넘어가면 숫자로 표현 못하니까 알파벳 가져온거 대소문자 구분 안함)
여기는 0x 붙임
0x01.... 0x0F, 0x10 (표시할거 없으면 리셋되고 앞에거 올라가는거 똑같음)

2진수와 16진수의 변환
2진수의 4자릿수로 표현가능한 형태는 총 16가지임 즉 16진수로 변환이 쉬움
0b10001111 = 0b 1000 1111 = 0x 08 0F = 0x080F
위에서처럼 4자리수로 끊으면 변환이 쉬움

1bit 는 00, 01 처럼 전기 신호가 있는지 없는지 판별하는 최소 단위
1byte는 1bit가 8개 있는거
0b11111111 = 0b10000000 + 0b01000000... + 0b00000001 = 255
따라서 1byte의 크기를 가진 자료형 byte가 표시할 수 있는 범위는 0~255

음수의 표현
가장 큰 10000000(128)을 음수로 사용 그러면 0b11111111 = -1
즉 1바이트는 -128~127 까지 표현 가능
이렇게 음수를 표현할 경우 0을 -0, +0 처럼 안 나누고 표현 가능
음수값을 양수값으로 바꾸는게 편함 (이진수 0, 1 뒤집고 1(0001) 더하면 됨)

4바이트 소수점 7자리 정도까지 정확
float f = 2.33f;

8바이트
double d = 2.33;

소수 연산은 정수형보다 훨씬 더 복잡하고 비쌈
double da = f + d;


형변환
byte fff = 255;
sbyte( -128 ~ 127 ) : 최상위 비트를 음수로 인식
sbyte kkk = (sbyte)fff;
byte에서 255는 0b11111111 sbyte에서는 최상위 비트(128)가 음수이므로 0b11111111 은 -1이므로 kkk의 값은 -1이 됨

int aaaa = 0x0FFFFFFF;
short bbbb = (short)aaaa;
short는 2비트까지만 0x0FFFFFFF 에서 앞의 0FFF 는 표현하지 못하고 뒤의 FFFF만 표현 가능하며 0xFFFF는 -1 이다.

break point : 디버그 모드로 실행했을 때 라인을 클릭하면 생기는 빨간 줄에서 코드가 끊기고 데이터 정보를 마우스 오버로 볼 수 있음

소수는 형변환 시 정확한 값이 아니라 가장 인접한 값을 내는 경우가 대부분이기 때문에 예상하지 못한 결과가 나올수도 있음
3.1414 변환하면 3.1414000623000122 로 변하고 그러기 때문에 조건문에서 == 보다는 오차를 어느 정도 감안하고 비교해야 함

int hp = 100;
hp++ 은 코드 실행 후 연산 ++hp는 코드 실행 전에 연산
Console.WriteLine(hp++);  100
Console.WriteLine(++hp);  101



비트 연산자 : <<  >>  &(and)  |(or)  ^(xor)  ~(not)
int num = 1;
<< : int는 4바이트로 0b00000000000000000000000000000001 인데 1을 왼쪽으로 3칸 밀어서 0b00000000000000000000000000001000 만드는 것
num = num << 3;
>> : 이건 왼쪽으로 미는거
num = num >> 3;

끝부분에서 더 밀면 절벽으로 떨어지는것마냥 0되버림

만약 음수를 포함하고 최상위 비트가 있는 상태를 밀면 밀리는게 최상위 비트는 남고 복사를 해버림
0b10000000000000010000000000000010 인 상태로 하나 밀면 0b11000000000000001000000000000001 가 되버림
그래서 비트 연산을 할때는 음수를 포함하지 않는 uint를 사용하면 좋음 uint( 0 ~ 43억 )
uint 사용하면 인생이 편해짐